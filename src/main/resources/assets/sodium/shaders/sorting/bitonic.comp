#version 460 core

#define MAX_BATCHES 256
#define QUADS_PER_WORKGROUP_BITS 8
#define QUADS_PER_WORKGROUP (1<<QUADS_PER_WORKGROUP_BITS)
#define QUADS_PER_WORKGROUP_MSK ((1<<QUADS_PER_WORKGROUP_BITS)-1)

uniform vec3 regionCamera;

uint baseIndexOffset;
uint quadCount;
uint baseVertexOffset;
vec3 camera;

struct SortBatch {
    uint baseIndexOffset;
    uint quadCount;
    uint baseVertexOffset;
    uint sectionId;
};

layout(binding = 0) uniform SortingBatchs {
    SortBatch batchs[MAX_BATCHES];
};

/*
struct QuadIndicies {
    int a;
    int b;
    int c;
};

uint getIndexBase(QuadIndicies indicies) {
    //Zeros out the lower bits
    return indicies.a&0xFFFC;
}
*/

struct Vertex {
    int a;
    int b;
    int c;
    int d;
    int e;
};

layout(std430, binding = 1) buffer QuadIndiciesBuffer {
    QuadIndicies indicies[];
};

layout(std430, binding = 2) buffer VertexBuffer {
    Vertex verticies[];
};

float unpackVertexPos(uint s) {
    return (float(s) * (32f/65536f))  - 8.0f;
}

float getDistance(uint quadId) {
    QuadIndicies i = indicies[quadId+baseIndexOffset];
    uint idA = getIndexBase(i)+baseVertexOffset;
    uint idB = getIndexBase(i)+2+baseVertexOffset;
    Vertex va = verticies[idA];
    Vertex vb = verticies[idB];
    vec3 pos = vec3(unpackVertexPos((va.a)&0xFFFF),unpackVertexPos((va.a>>16)&0xFFFF),unpackVertexPos((va.b)&0xFFFF));
    pos += vec3(unpackVertexPos((vb.a)&0xFFFF),unpackVertexPos((vb.a>>16)&0xFFFF),unpackVertexPos((vb.b)&0xFFFF));
    pos /= 2;

    vec3 delta = abs(pos+camera);
    return delta.x+delta.y+delta.z;
}



layout(local_size_x = (QUADS_PER_WORKGROUP/2), local_size_y = 1 , local_size_z = 1) in;
shared float threadBufferFloat[QUADS_PER_WORKGROUP];
shared uint threadBufferIndex[QUADS_PER_WORKGROUP];

uint baseId = gl_LocalInvocationID.x<<1;

void populate() {
    threadBufferFloat[baseId|0] = 0.0f;
    threadBufferFloat[baseId|1] = 0.0f;
    threadBufferIndex[baseId|0] = baseId|0;
    threadBufferIndex[baseId|1] = baseId|1;
    if (baseId < quadCount) {
        threadBufferFloat[baseId|0] = getDistance(baseId);
    }
    if ((baseId|1) < quadCount) {
        threadBufferFloat[baseId|1] = getDistance(baseId|1);
    }
    barrier();
    memoryBarrierShared();
}

void update() {
    QuadIndicies A = indicies[threadBufferIndex[baseId|0]+baseIndexOffset];
    QuadIndicies B = indicies[threadBufferIndex[baseId|1]+baseIndexOffset];
    barrier();
    if (baseId < quadCount) {
        indicies[baseId+baseIndexOffset] = A;
    }
    if ((baseId|1) < quadCount) {
        indicies[(baseId|1)+baseIndexOffset] = B;
    }
}


void localSortA(const uint scaleBits) {
    uint base = (gl_LocalInvocationID.x>>scaleBits)*(1<<(scaleBits+1));
    uint offsetA = (gl_LocalInvocationID.x&((1<<scaleBits)-1));
    uint offsetB = (1<<(scaleBits+1))-1-offsetA;
    float a = threadBufferFloat[base + offsetA];
    float b = threadBufferFloat[base + offsetB];
    if (a < b) {
        threadBufferFloat[base + offsetA] = b;
        threadBufferFloat[base + offsetB] = a;

        uint tmp = threadBufferIndex[base + offsetA];
        threadBufferIndex[base + offsetA] = threadBufferIndex[base + offsetB];
        threadBufferIndex[base + offsetB] = tmp;
    }

    barrier();
    memoryBarrierShared();
}

void localSortB(const uint scaleBits) {
    uint base = (gl_LocalInvocationID.x>>scaleBits)*(1<<(scaleBits+1));
    base += (gl_LocalInvocationID.x&((1<<scaleBits)-1));
    uint offset = 1<<scaleBits;
    float a = threadBufferFloat[base];
    float b = threadBufferFloat[base + offset];
    if (a < b) {
        threadBufferFloat[base] = b;
        threadBufferFloat[base + offset] = a;

        uint tmp = threadBufferIndex[base];
        threadBufferIndex[base] = threadBufferIndex[base + offset];
        threadBufferIndex[base + offset] = tmp;
    }

    barrier();
    memoryBarrierShared();
}

void main() {
    SortBatch batch = batchs[gl_WorkGroupID.x];
    baseIndexOffset = batch.baseIndexOffset;
    quadCount = batch.quadCount;
    baseVertexOffset = batch.baseVertexOffset;
    camera = vec3(((uvec3(batch.sectionId)>>uvec3(5, 3, 0))&uvec3(7,3,7))<<4)+regionCamera;

    populate();

    //Net 0
    localSortA(0);
    //Net 1
    localSortA(1);
    localSortB(0);
    //Net 2
    localSortA(2);
    localSortB(1);
    localSortB(0);
    //Net 3
    localSortA(3);
    localSortB(2);
    localSortB(1);
    localSortB(0);
    //Net 4
    localSortA(4);
    localSortB(3);
    localSortB(2);
    localSortB(1);
    localSortB(0);
    //Net 5
    localSortA(5);
    localSortB(4);
    localSortB(3);
    localSortB(2);
    localSortB(1);
    localSortB(0);
    //Net 6
    localSortA(6);
    localSortB(5);
    localSortB(4);
    localSortB(3);
    localSortB(2);
    localSortB(1);
    localSortB(0);
    //Net 7
    localSortA(7);
    localSortB(6);
    localSortB(5);
    localSortB(4);
    localSortB(3);
    localSortB(2);
    localSortB(1);
    localSortB(0);

    update();
}
